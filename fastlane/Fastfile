require 'dotenv'
Dotenv.load("../.env")

def get_env(name)
  value = ENV[name]
  raise "Forgot to define #{name} in .env" unless value 

  return value 
end 

UI = FastlaneCore::UI unless Fastlane.const_defined?("UI")

env = {
  :bundle_id => get_env("APP_BUNDLE_ID"),
  :admin_email => get_env("ADMIN_EMAIL"),
  :app_name => get_env("APP_NAME"),
  :testflight_beta_feedback_email => get_env("TESTFLIGHT_BETA_FEEDBACK_EMAIL"),
  :xcode_scheme => get_env("XCODE_SCHEME"),
  :app_icon_badge => get_env("APP_ICON_BADGE")
}

default_platform :ios

platform :ios do

  before_all do |lane, options|
    setup_travis
  end

  # Requires `brew install imagemagick` for framing to work
  desc "Take screenshots for the store"
  lane :take_screenshots do |values|
    capture_ios_screenshots(
      skip_open_summary: true
    )    
    frame_screenshots()
  end 
  
  desc "Downloads dsym files from iTunes Connect (from processed builds by Apple) and uploads them to Crashlytics for reports."  
  lane :refresh_dsyms do |values| 
    download_dsyms(
      min_version: values[:min_version],
      version: values[:version] || "latest",
      app_identifier: values[:app_id] || env[:bundle_id]
    )
    upload_symbols_to_crashlytics(
      gsp_path: "Src/GoogleService-Info.plist"
    )
    clean_build_artifacts
  end

  desc "From a .env file, change the app's properties. It's easier to do in fastlane, so that's why we're doing it here."
  lane :set_environment do 
    info_plist_location = "Src/Info.plist"
  
    update_app_identifier(
      app_identifier: env[:bundle_id],
      plist_path: info_plist_location
    )  

    update_info_plist(      
      plist_path: info_plist_location,
      display_name: env[:app_name]
    )
  end

  lane :deploy do |values|
    UI.user_error!('Not on CI') unless ENV["CI"]

    generate_icons()

    changelog = File.read("./release_notes.txt")    
    description = File.read("./metadata/en-US/description.txt")    
    buildVersion = Time.now.to_i.to_s
    
    sync_code_signing(type: "appstore")

    set_info_plist_value(path: "./Src/Info.plist", key: "CFBundleVersion", value: buildVersion) # Set bundle version to epoch time to assert it's always unique.
    
    if ENV["TRAVIS_TAG"].end_with?("-beta")
      beta_build_release(changelog, description)

      publicity_message = "This update is *not* available to the public. The update was uploaded to the TestFlight app and is only available for beta testing. You can download the update with the TestFlight app on your phone, now."
      notify_app_update(buildVersion, publicity_message)
    else
      take_screenshots()
      prod_build_upload()
    end     
  end 

  desc "Meant to be called from a local machine. Not from a CI server"
  lane :submit_prod_release do |values|
    UI.user_error!('Does not run on CI') if ENV["CI"]

    appVersion = values[:app_version]
    UI.user_error!("Forgot to pass in app_version") unless appVersion
    UI.message("Submitting app. Name: #{env[:app_name]}, version: #{appVersion}. Correct? [Hit Enter for Yes]")    
    gets
    UI.message("You checked the metadata and screenshots for the release, correct? [Hit Enter for Yes]")    
    gets 

    buildVersion = app_store_build_number(
      live: false,
      version: appVersion
    )   

    upload_to_app_store(
      build_number: buildVersion,
      force true, # Skip the HTML report file verification
      submit_for_review: true,
      automatic_release: true,
      skip_metadata: true,
      skip_screenshots: true,
      skip_binary_upload: true
    )

    publicity_message = "This update was submitted to the Apple App Store so that it can be availble to the public. However, the app must be approved by Apple for it to be available to the public. This approval process takes between 1 to 4 days."
    notify_app_update(appVersion, buildVersion, publicity_message, latest_demo)
  end 

  def notify_app_update(buildVersion, publicity_message)
    latest_demo = File.read('./latest_demo.txt')
    versionOfApp = get_version_number(target: env[:xcode_scheme])

    notification_message_body = [      
      "#{env[:app_name]} v#{versionOfApp}, build: #{buildVersion} ready for download.",
      "#{publicity_message}",
      "\n",
      "Link to demo and notes for the latest release:",
      latest_demo,
      "\n",
      "(Note: this is an automated message. Please email #{env[:admin_email]} if you have questions)"
    ].join("\n") + "\n"

    aws_sns_topic(
      access_key: ENV["AWS_IAM_ACCESS_KEY"],
      secret_access_key: ENV["AWS_IAM_ACCESS_SECRET"],
      region: ENV["AWS_REGION"],
      topic_arn: ENV["AWS_SNS_APP_UPDATE_TOPIC"],
      subject: "#{env[:app_name]} v#{versionOfApp} app update",
      message: notification_message_body
    )
  end 

  desc "Build and upload beta app to TestFlight"
  def beta_build_release(changelog, description)
    build_ios_app(
      scheme: env[:xcode_scheme],
      configuration: 'Release',
      export_method: 'app-store',
      output_name: "Prod.ipa",
      output_directory: 'build')

    testflight(
      changelog: changelog,
      beta_app_description: description,
      beta_app_feedback_email: env[:testflight_beta_feedback_email],
      distribute_external: false,
      ipa: './build/Prod.ipa',
      app_platform: 'ios',
      wait_for_uploaded_build: true,
      skip_waiting_for_build_processing: false) # I have decided to not skip waiting for build process because with testflight, skipping will result in changelog and such not being updated and sending app to external testers.
  end

  desc "Build and upload production app to the App Store. Note: This does *not* submit for review."
  def prod_build_upload
    build_ios_app(
      scheme: env[:xcode_scheme],
      configuration: 'Release',
      export_method: 'app-store',
      output_name: "Prod.ipa",
      output_directory: 'build')
    
    upload_to_app_store(
      ipa: './build/Prod.ipa',
      precheck_default_rule_level: :error) 
  end

  # You must: `brew install graphicsmagick` to install the GraphicsMagick library as required by `appicon` action
  # You must `brew install librsvg` to install RSVG as required by `add_badge` action
  lane :generate_icons do    
    app_icon_path = "./fastlane/icons/icon.jpg"

    appicon(appicon_image_file: app_icon_path,
      appicon_devices: [:ipad, :iphone, :ios_marketing],
      appicon_path: "Src/Assets/Assets.xcassets",
      appicon_name: "AppIcon.appiconset")

    badge = env[:app_icon_badge]
    if badge != "no"
      add_badge(
        glob: "/**/AppIcon.appiconset/*.{png,PNG}",
        dark: false, # add a dark badge instead of white one.
        alpha: badge == "alpha", # uses "alpha" text instead of "beta"
        badge_gravity: "SouthEast" # where to position the badge 
      )
    end
  end
end